
This has the ability to respond to both code (noweb file input) and data
(standard input) changes simultaneously.

<<build>>=
CHMOD='chmod 0555' nofake.sh --error -Rnofake-exec.sh -onofake-exec.sh shell.nw temporary-files-shell.nw nofake-exec.nw
@

<<*>>=
<<build>>
seq 3 | ./nofake-exec.sh -R'test' nofake-exec.nw -- cat -vet -
seq 3 | ./nofake-exec.sh -R'test' nofake-exec.nw --aa - -- cat -vet
@

<<nofake-exec.sh>>=
<<sh preamble>>
# generated from nofake-exec.nw
<<function die>>
<<zsh expansion fix>>
<<function temporary_file>>

SRC_PREFIX=${SRC_PREFIX:-}
NOFAKE_SH=${NOFAKE_SH:-nofake.sh}
NOFAKE_SH_FLAGS=${NOFAKE_SH_FLAGS:-}

nargs= # nofake args
eargs= # exec args

for arg do
    if [ x"${arg}" = x-- ]; then shift; break; fi
    nargs="${nargs:+${nargs} }'${arg}'"
    shift # 'for' is synchronized with 'shift'
done

if [ x$# = x0 ]; then
    die 1 "Error, wrong usage, exec arguments are absent."
fi

for arg do eargs="${eargs:+${eargs} }'${arg}'"; done

<<nofake.sh part>>
<<run part>>
@

${tmps} are additional suffixes to generate along with ${output}

<<nofake.sh part>>=
eval "set -- ${nargs}"

opts=
chunks=
sources=
output=
appendargs=
tmps=

while [ $# -gt 0 ]; do
    case "${1}" in
        -L*|--error) opts="${opts:+${opts} }'${1}'" ;;
        -R*) chunks="${chunks:+${chunks} }'${1}'" ;;

        -o|--output) output=${2}; shift ;;
        --output=*) output=${1#*=} ;;
        -o*) output=${1#??} ;;

        --tmp) tmps="${tmps:+${tmps} }'${2}'"; shift ;;
        --tmp=*) tmps="${tmps:+${tmps} }'${1#*=}'" ;;

        --aa) appendargs="${appendargs:+${appendargs} }'${2}'"; shift ;;
        --aa=*) appendargs="${appendargs:+${appendargs} }'${1#*=}'" ;;

        # double-dash
        --dd|--dd--) appendargs="${appendargs:+${appendargs} }'--'" ;;

        -) sources="${sources:+${sources} }'-'" ;;
        -*)
            ${ECHO} "${0##*/}: Unrecognized option '${1}'." 1>&2
            exit 1
            ;;
        *) sources="${sources:+${sources} }'${SRC_PREFIX}${1}'" ;;
    esac
    shift
done

if [ x"${output}" = x ]; then
    # stamp file is generated by nofake.sh
    output=`temporary_file`
    tmpfiles="${tmpfiles:+${tmpfiles} }'${output}'"
    tmpfiles="${tmpfiles:+${tmpfiles} }'${output}.stamp'"

    eval "set -- ${tmps}"
    for arg; do
        if [ x"${arg}" = x ]; then
            die 1 "Error, additional temporary file suffix cannot be empty."
        fi
        if [ x"${arg}" = x.stamp ]; then
            die 1 "Error, additional temporary file suffix \".stamp\" is already used."
        fi
        tmpfiles="${tmpfiles:+${tmpfiles} }'${output}${arg}'"
    done
fi

eval "set -- ${opts} ${chunks} ${sources}"
${NOFAKE_SH} ${NOFAKE_SH_FLAGS} "$@" -o"${output}"
@

Schedule temporary files removal (due to losing trap due to 'exec') then
'exec'. This, unlink operation, won't affect already opened files.

Close stdout and stderr on cleaner subprocess, so original process do not hang
on pipe redirection.

May be fork and waitpid is more appropriate afterall, there are situations
where the program startup takes longer than one second and by then the file is
already gone, java is a good example.

<<run part -- with exec>>=
eval "set -- ${tmpfiles}"
sh -c 'exec >&- 2>&-; sleep 1; exec rm -f "$@"' -- "$@" &
eval "set -- ${eargs} '${output}' ${appendargs}"
exec "$@"
@

<<run part -- with fork and waitpid>>=
eval "set -- ${eargs} '${output}' ${appendargs}"
"$@"
@

<<run part>>=
<<run part -- with fork and waitpid>>
@

<<test>>=
hello world!
@

nofake -R'test example.sh' nofake-exec.nw

<<test example.sh>>=
CHMOD='chmod 0555' nofake.sh -Rexample.sh -oexample.sh nofake-exec.nw
./example.sh | nofake-exec.sh -Rcompute.pl -o.compute.pl .example.nw -- perl -wl
@

<<example.sh>>=
#!/bin/sh
cat@<<EOF>.example.nw
@<<compute.pl>>=
my \$sum = $$;
while(<>){
    chomp;
    \$sum += \$_;
}
print(\$sum);
@@
EOF

exec seq 10
@
