
This has the ability to respond to both code (noweb file input) and data
(standard input) changes simultaneously.

<<simple example>>=
seq 3 | ./nofake-exec.sh -R'test' nofake-exec.nw -- cat -vet -
seq 3 | ./nofake-exec.sh -R'test' nofake-exec.nw --aa-- - -- cat -vet
seq 3 | ./nofake-exec.sh -R'test' nofake-exec.nw --ba-- - --ea-- -- cat -vet
@

another example of a fundamental difference:

    ./nofake         -R'is fd 0 a tty?' nofake-exec.nw |  sh -eu
    ./nofake-exec.sh -R'is fd 0 a tty?' nofake-exec.nw -- sh -eu

<<is fd 0 a tty?>>=
if [ -t 0 ]; then
    echo 'fd 0 (stdin) is a tty'
else
    echo 'fd 0 (stdin) is likely a pipe'
fi
@

<<*>>=
<<build nofake-exec.sh>>
<<simple example>>
@

<<nofake-exec.sh>>=
<<sh preamble>>
# generated from nofake-exec.nw
<<function die>>
<<zsh expansion fix>>
<<function temporary_file>>
<<function normalize_arg>>

SRC_PREFIX=${SRC_PREFIX:-}
NOFAKE_SH=${NOFAKE_SH:-nofake.sh}
NOFAKE_SH_FLAGS=${NOFAKE_SH_FLAGS:-}
ECHO=${ECHO:-echo}
ECHO_ERROR=${ECHO_ERROR:-echo}
ECHO_INFO=${ECHO_INFO:-echo}

nargs= # nofake args
eargs= # exec args

skipdd=0 # skip double dash

for arg do
    if [ x"${skipdd}" = x0 ]; then
        if [ x"${arg}" = x--ba-- ]; then
            skipdd=1
        elif [ x"${arg}" = x-- ]; then
            shift
            break
        fi
    else
        if [ x"${arg}" = x--ea-- ]; then
            skipdd=0
        fi
    fi
    nargs="${nargs:+${nargs} }'`normalize_arg "${arg}"`'"
    shift # 'for' is synchronized with 'shift'
done

if [ x$# = x0 ]; then
    die 1 "Error, wrong usage, exec arguments are absent." 1>&2
fi

for arg do
    eargs="${eargs:+${eargs} }'`normalize_arg "${arg}"`'"
done

<<nofake.sh part>>
<<run part>>
@

${tmps} are additional suffixes to generate along with ${output}

<<nofake.sh part>>=
eval "set -- ${nargs}"

opts=
chunks=
sources=
output=
appendargs=
tmps=
suffix=
skip_append_output=

while [ $# -gt 0 ]; do
    case "${1}" in
        -L*|--error) opts="${opts:+${opts} }'`normalize_arg "${1}"`'" ;;
        -R*) chunks="${chunks:+${chunks} }'`normalize_arg "${1}"`'" ;;

        -o|--output) output=`normalize_arg "${2}"`; shift ;;
        --output=*) output=`normalize_arg "${1#*=}"` ;;
        -o*) output=`normalize_arg "${1#??}"` ;;

        --tmp--) tmps="${tmps:+${tmps} }'`normalize_arg "${2}"`'"; shift ;;

        --aa--) appendargs="${appendargs:+${appendargs} }'`normalize_arg "${2}"`'"; shift ;;
        --dd--) appendargs="${appendargs:+${appendargs} }'--'" ;;

        --ba--) # begin args
            shift
            for arg; do
                if [ x"${arg}" = x--ea-- ]; then
                    # end args
                    break
                fi
                appendargs="${appendargs:+${appendargs} }'`normalize_arg "${1}"`'"
                shift # 'for' is synchronized with 'shift'
            done
            ;;

        --suffix) suffix=`normalize_arg "${2}"`; shift ;;
        --suffix=*) suffix=`normalize_arg "${1#*=}"` ;;

        --skip-append-output) skip_append_output=1 ;;

        -) sources="${sources:+${sources} }'-'" ;;
        -*)
            ${ECHO_ERROR} "${0##*/}: Unrecognized option '${1}'." 1>&2
            exit 1
            ;;

        *) sources="${sources:+${sources} }'${SRC_PREFIX}`normalize_arg "${1}"`'" ;;
    esac
    shift
done

if [ x"${output}" = x ]; then
    # stamp file is generated by nofake.sh
    output=`temporary_file "${suffix}"`
    tmpfiles="${tmpfiles:+${tmpfiles} }'${output}'"
    tmpfiles="${tmpfiles:+${tmpfiles} }'${output}.stamp'"

    eval "set -- ${tmps}"
    for arg; do
        if [ x"${arg}" = x ]; then
            die 1 "Error, additional temporary file suffix cannot be empty." 1>&2
        fi
        if [ x"${arg}" = x.stamp ]; then
            die 1 "Error, additional temporary file suffix \".stamp\" is already used." 1>&2
        fi
        if [ x"${suffix}" != x -a x"${arg}" = x"${suffix}" ]; then
            die 1 "Error, additional temporary file suffix matches the default \"${suffix}\"." 1>&2
        fi
        tmpfiles="${tmpfiles:+${tmpfiles} }'${output}${arg}'"
        tmpfiles="${tmpfiles:+${tmpfiles} }'${output}${arg}.stamp'"
    done
fi

eval "set -- ${opts} ${chunks} ${sources}"
ECHO_INFO=: ${NOFAKE_SH} ${NOFAKE_SH_FLAGS} "$@" -o"${output}"
@

Schedule temporary files removal (due to losing trap due to 'exec') then
'exec'. This, unlink operation, won't affect already opened files.

Close stdout and stderr on cleaner subprocess, so original process do not hang
on pipe redirection.

May be fork and waitpid is more appropriate afterall, there are situations
where the program startup takes longer than one second and by then the file is
already gone, java is a good example.

<<run part -- with exec>>=
eval "set -- ${tmpfiles}"
sh -c 'exec >&- 2>&-; sleep 1; exec rm -f "$@"' -- "$@" &
<<run part -- set arguments>>
exec "$@"
@

<<run part -- with fork and waitpid>>=
<<run part -- set arguments>>
"$@"
@

<<run part>>=
<<run part -- with fork and waitpid>>
@

<<run part -- set arguments>>=
eval "set -- ${eargs}"
if [ x"${skip_append_output}" != x1 ]; then
    eval "set -- "'"$@"'" '${output}'"
fi
eval "set -- "'"$@"'" ${appendargs}"
@

<<test>>=
hello world!
@

nofake -R'test example.sh' nofake-exec.nw

<<test example.sh>>=
CHMOD='chmod 0555' nofake.sh -Rexample.sh -oexample.sh nofake-exec.nw
./example.sh | nofake-exec.sh -Rcompute.pl -o.compute.pl .example.nw -- perl -wl
@

<<example.sh>>=
#!/bin/sh
cat@<<EOF>.example.nw
@<<compute.pl>>=
my \$sum = $$;
while(<>){
    chomp;
    \$sum += \$_;
}
print(\$sum);
@@
EOF

exec seq 10
@

<<nofake-exec.sh deps>>=
shell.nw temporary-files-shell.nw nofake-exec.nw
@

<<build nofake-exec.sh>>=
CHMOD='chmod 0555' nofake.sh --error -Rnofake-exec.sh -onofake-exec.sh \
    "$@"
@
