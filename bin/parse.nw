
nofake -RWIP parse.nw | sh

<<WIP>>=
#!/bin/sh
set -eu
make tokenize parse
./tokenize nofake.nw | ./parse
@

'nofake parse.nw' for build instructions

<<Define CONVERT_CRLF_TO_LF>>=
#define CONVERT_CRLF_TO_LF 1
@

<<chop nl>>=
if (line_length < 3) { /* CATEGORY RESERVED [ DATA ] LF */
    fprintf(stderr, "Exhaustion %s:%d.", __FILE__, __LINE__);
    exit(1);
}
line_length--;
@

<<Variables local to [[main]]>>=
long input_line_number = 0;
struct tkinfo_file_name *tkinfo_file_name = NULL;
struct tkinfo_line_number *tkinfo_line_number = NULL;
struct queue_64 tokens;
@

<<Local variables initialization>>=
SETUP_QUEUE_64(tokens);
@

<<initialize tokens queue>>=

@

<<Process Line - vars>>=
size_t line_length = ptr - line_start;
struct strscan ctx[1];
char *b;
struct token *token = NULL;
@

<<set strscan context>>=
strscan(ctx, line_start, line_length);
@

<<Process Line>>=
<<Process Line - vars>>
<<chop nl>>
<<set strscan context>>
b = ctx->beg;
switch (*b) {
    case '0':
        ctx->pos += 2;
        input_line_number = 1;
        tkinfo_file_name = new_tkinfo_file_name(ctx);
        tkinfo_line_number = new_tkinfo_line_number(tkinfo_file_name,
            input_line_number);
        break;
    case '1':
        ctx->pos += 2;
        input_line_number++;
        tkinfo_line_number = new_tkinfo_line_number(tkinfo_file_name,
            input_line_number);
        break;
    case '2': /* EOF */
        break;
    case '3': /* isalnum(c) || c == '_' */
        ctx->pos += 2;
        token = new_token_image(tkinfo_line_number, 3, ctx);
        break;
    case '4': /* c == ' ' || c == '\t' */
        ctx->pos += 2;
        token = new_token_image(tkinfo_line_number, 4, ctx);
        break;
    case '5': /* ispunct(c) */
        token = new_token_punct(tkinfo_line_number, 5, b[2]);
        break;
    case '6': { /* c <= 127 */
            ctx->pos += 2;
            if (STRSCAN_LEN(ctx) != 2) {
                fprintf(stderr, "Exhaustion %s:%d.", __FILE__, __LINE__);
                exit(1);
            }
            token = new_token_hi_lo(tkinfo_line_number, 6, b[2], b[3]);
        }
        break;
    default:
        fprintf(stderr, "Exhaustion %s:%d.", __FILE__, __LINE__);
        exit(1);
        break;
}
if (token) {
    enqueue(tokens.queue, token);
    if (token->image) {
        printf("token category %d, line %d: [%s]\n",
            token->category, token->line_number->line_number,
            token->image);
    } else if (token->category == 5) {
        printf("token category %d, line %d: '%c'\n",
            token->category, token->line_number->line_number,
            token->value.punct);
    } else if (token->category == 6) {
        char *hi_lo;
        hi_lo = token->value.hi_lo;
        /* 0x00..0xFF -> 0y@@..0yOO */
        /* 0xBF = ~0x40 & 0xFF */
        c = (hi_lo[0] & 0xBF) << 4 | (hi_lo[1] & 0xBF);
        printf("token category %d, line %d: 0x%02x (0y%c%c)\n",
            token->category, token->line_number->line_number,
            c, hi_lo[0], hi_lo[1]);
    } else {
        fprintf(stderr, "Exhaustion %s:%d.", __FILE__, __LINE__);
        exit(1);
    }
}
@

<<The main program>>=
int main(int argc, char **argv)
{
    <<Variables local to [[main]]>>
    <<Local variables initialization>>
    <<Set up option selection>>
    <<Process all the files>>
    <<Exit status>>
}
@

<<parse.c>>=
<<C Standards>>
<<Header files to include>>
<<Definitions>>
<<Types>>
<<Protos>>
<<Global variables>>
<<Auxiliary Functions>>
<<The main program>>
@

<<C Standards>>=
#ifndef _BSD_SOURCE
#define _BSD_SOURCE
#endif
#ifndef _ISOC99_SOURCE
#define _ISOC99_SOURCE
#endif
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif
#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif
@

<<Header files to include>>=
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <ctype.h>
@

stdio.h BUFSIZ chosen for efficiency, BUF_SIZE also dictates the maximum line
length

<<Define BUF_SIZE>>=
#if BUFSIZ >= 512
#define BUF_SIZE            BUFSIZ
#else
#define BUF_SIZE            512
#endif
@

<<Definitions>>=
#define OK                  0   /* status code for successful run */
#define CANNOT_OPEN_FILE    1   /* status code for file access error */
#define LINE_TOO_LONG       2   /* line longer than BUF_SIZE - 1 */
#define READ_ONLY           0   /* read access code for system open */
<<Define BUF_SIZE>>
<<Define CONVERT_CRLF_TO_LF>>
@

<<Global variables>>=
int status = OK;        /* exit status of command, initially OK */
char *prog_name;        /* who we are */
long tot_line_count;    /* total number of lines */
@

<<Update grand totals>>=
tot_line_count += line_count;
@

<<Close file>>=
close(fd);
@

<<Fill [[buffer]] if it is empty; [[break]] at end of file>>=
if (ptr >= buf_end) {
    size_t consumed = ptr - buffer;
    size_t remaining = BUF_SIZE - consumed;
    if (remaining == 0) {
        size_t line_length = ptr - line_start;
        if (line_start == buffer) {
            fprintf(stderr,
                "Error in %s, line %s:%lu is too long, greater than %lu\n",
                prog_name, file_name, line_count + 1,
                (unsigned long)(buf_end - buffer));
            status |= LINE_TOO_LONG;
            break;
        }
        line_start = memmove(buffer, line_start, line_length);
        ptr = buf_end = line_start + line_length;
        consumed = line_length;
        remaining = BUF_SIZE - consumed;
    }
    nc = read(fd, ptr, remaining);
    if ((got_eof = (nc <= 0))) {
        if (buf_end > line_start && *(buf_end-1) != '\n') {
            if (got_cr) {
                /* a CR by itself is always converted to a LF */
                got_cr = 0;
                *(buf_end-1) = '\n';
                ptr--; /* repeat */
            } else {
                *buf_end++ = '\n';
                consumed++;
                remaining--;
                got_eof = 0; /* retry */
            }
        } else {
            break;
        }
    } else {
        buf_end = ptr + nc;
    }
}
@

<<Scan buffer>>=
while (got_eof == 0) {
    <<Fill [[buffer]] if it is empty; [[break]] at end of file>>
    c = *ptr++;
    if (c == '\n') {
        /* lf or cr-lf */
#if CONVERT_CRLF_TO_LF
        ptr -= got_cr;
        *(ptr - 1) = '\n';
#endif
        line_count++;
        {
            <<Process Line>>
        }
#if CONVERT_CRLF_TO_LF
        ptr += got_cr;
#endif
        line_start = ptr;
        got_cr = 0;
    } else if (got_cr) {
        /* cr, convert to lf and repeat */
        got_cr = 0;
        ptr -= 2;
        *ptr = '\n';
    } else {
        got_cr = c == '\r';
    }
}
@

<<Scan file>>=
line_start = ptr = buffer;
nc = read(fd, ptr, BUF_SIZE);
if (nc > 0) {
    buf_end = buffer + nc;
    <<Scan buffer>>
}
@

<<Initialize pointers and counters>>=
line_start = ptr = buffer;
line_count = 0;
@

<<If a file is given, try to open [[*(++argv)]]; [[continue]] if unsuccessful>>=
if (file_count > 0) {
    file_name = *(++argv);
    if (strcmp(file_name, "-") == 0) {
        fd = 0; /* stdin */
    } else if ((fd = open(file_name, READ_ONLY)) < 0) {
        fprintf(stderr,
            "%s: cannot open file %s\n",
            prog_name, file_name);
        status |= CANNOT_OPEN_FILE;
        file_count--;
        continue;
    }
} else {
    fd = 0; /* stdin */
    file_name = "-";
}
@

<<Process all the files>>=
argc--;
do {
    <<If a file is given, try to open [[*(++argv)]]; [[continue]] if unsuccessful>>
    <<Initialize pointers and counters>>
    <<Scan file>>
    <<Close file>>
    <<Update grand totals>>
} while (--argc > 0);
@

<<Set up option selection>>=
file_count = argc - 1;
@

<<Variables local to [[main]]>>=
int file_count;         /* how many files there are */
char *file_name;        /* Used to differentiate between *argv and '-' */
int fd;                 /* file descriptor */
char buffer[BUF_SIZE];  /* we read the input into this array */
char *ptr;              /* first unprocessed character in buffer */
char *line_start;       /* where in the buffer the current line starts */
char *buf_end;          /* the first unused position in buffer */
int c;                  /* current char */
ssize_t nc;             /* # of chars just read */
long line_count;        /* # of words, lines, and chars so far */
int got_eof = 0;        /* read got EOF */
int got_cr = 0;         /* previous char was '\r' */
@

<<Local variables initialization>>=
prog_name = argv[0];
@

<<Exit status>>=
exit(status);
return 0;
@

<<Definitions>>=
<<definitions>>
<<Types>>=
<<structs>>
<<Auxiliary Functions>>=
<<impl>>
<<Protos>>=
<<protos>>
<<Global variables>>=
<<globals>>
<<Local variables initialization>>=
<<globals initialization>>
@

nofake parse.nw | sh -eux

<<*>>=
#!/bin/sh
set -eu
<<build parse.c>>
<<build parse>>
@

[[targets]] are used by automatic Makefile generation, see [[Makefile.nw]] for
details.

<<targets>>=
set -- "$@" parse.c
set -- "$@" parse
@

<<parse.c deps>>=
parse.nw strscan.nw tkscan.nw queue.nw debug.nw reallocarray.nw
@

<<parse deps>>=
parse.c
@

<<build parse.c>>=
CHMOD='chmod 0444' nofake.sh --error -L -Rparse.c -oparse.c <<parse.c deps>>
@

<<build parse - DEBUG>>=
gcc -O0 -g -Wall -ansi -pedantic -o parse parse.c
@

<<build parse - STANDARD>>=
gcc -O2 -Wall -ansi -pedantic -o parse parse.c
@

<<set build PEDANTIC>>=
set -- "$@" -ansi -pedantic
set -- "$@" -Wall -Wextra -Wdeclaration-after-statement
set -- "$@" -Wstrict-prototypes -Wmissing-prototypes
set -- "$@" -Wredundant-decls
set -- "$@" -Wshadow
set -- "$@" -Wpointer-arith
set -- "$@" -Wno-unused-parameter
set -- "$@" -Werror -fmax-errors=3
@

<<build parse - PEDANTIC>>=
set --
<<set build PEDANTIC>>
gcc -O2 "$@" -o parse parse.c
@

<<build parse>>=
#!/bin/sh
set -eu
#@<<build parse - DEBUG>>
#@<<build parse - STANDARD>>
<<build parse - PEDANTIC>>
@

<<tests.sh>>=
#!/bin/sh
set -eux
make parse
@
