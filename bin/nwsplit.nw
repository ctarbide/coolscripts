
A REPL example inspired by [WCNI], made to be paired with [RLWRAP].

[WCNI]: https://www.cs.tufts.edu/~nr/noweb/examples/wcni.html

[RLWRAP]: https://github.com/hanslub42/rlwrap

'nofake nwsplit.nw' for build instructions

<<Define CONVERT_CRLF_TO_LF>>=
#define CONVERT_CRLF_TO_LF 1
@

<<Definitions>>=
#define STATE_DOCUMENTATION 0
#define STATE_FOUND_CHUNK 1
#define STATE_CHUNK_LINE 2
#define STATE_FOUND_END_OF_CHUNK 3
@

smallest start of chunk:

    [[<<?>>=]]

, 7 bytes (plus new line) in length

<<found chunk?>>=
1
@

<<identify and set state>>=
if (<<found chunk?>>) {
    state = STATE_FOUND_CHUNK;
    (void)state;
}
@

cr-lf -> lf
cr -> lf

printf -- 'a\ncr\rb\n' | hexdump -Cv
printf -- 'a\ncr\rb\n' | ./nwsplit

<<Process Line - vars>>=
size_t line_length = ptr - line_start;
int state = STATE_DOCUMENTATION;
@

<<chop>>=
line_start[--line_length] = '\0';
@

<<Process Line>>=
<<Process Line - vars>>
if (line_length == 0) {
    fprintf(stderr, "Exhaustion %s:%d.", __FILE__, __LINE__);
    exit(1);
}
<<chop>>
printf("**** line %s:%lu has %lu bytes: [", file_name, line_count,
    (unsigned long)line_length);
fwrite(line_start, line_length, 1, stdout);
printf("]\n");
<<identify and set state>>
@

<<The main program>>=
int main(int argc, char **argv)
{
    <<Variables local to [[main]]>>
    <<Local variables initialization>>
    <<Set up option selection>>
    <<Process all the files>>
    <<Exit status>>
}
@

<<nwsplit.c>>=
<<C Standards>>
<<Header files to include>>
<<Definitions>>
<<Global variables>>
<<The main program>>
@

<<C Standards>>=
#ifndef _BSD_SOURCE
#define _BSD_SOURCE
#endif

#ifndef _ISOC99_SOURCE
#define _ISOC99_SOURCE
#endif

#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif
@

<<Header files to include>>=
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
@

stdio.h BUFSIZ chosen for efficiency, BUF_SIZE also dictates the maximum line
length

<<Define BUF_SIZE>>=
#if BUFSIZ >= 512
#define BUF_SIZE            BUFSIZ
#else
#define BUF_SIZE            512
#endif
@

<<Definitions>>=
#define OK                  0   /* status code for successful run */
#define CANNOT_OPEN_FILE    1   /* status code for file access error */
#define LINE_TOO_LONG       2   /* line longer than BUF_SIZE - 1 */
#define READ_ONLY           0   /* read access code for system open */
<<Define BUF_SIZE>>
<<Define CONVERT_CRLF_TO_LF>>
@

<<Global variables>>=
int status = OK;    /* exit status of command, initially OK */
char *prog_name;    /* who we are */
/* total number of lines */
long tot_line_count;
@

long line_count;    /* given totals */

<<Update grand totals>>=
tot_line_count += line_count;
@

<<Close file>>=
close(fd);
@

<<Fill [[buffer]] if it is empty; [[break]] at end of file>>=
if (ptr >= buf_end) {
    size_t consumed = ptr - buffer;
    size_t remaining = BUF_SIZE - consumed;
    if (remaining == 0) {
        size_t line_length = ptr - line_start;
        if (line_start == buffer) {
            fprintf(stderr,
                "Error in %s, line %s:%lu is too long, greater than %lu\n",
                prog_name, file_name, line_count + 1,
                (unsigned long)(buf_end - buffer));
            status |= LINE_TOO_LONG;
            break;
        }
        line_start = memmove(buffer, line_start, line_length);
        ptr = buf_end = line_start + line_length;
        consumed = line_length;
        remaining = BUF_SIZE - consumed;
    }
    nc = read(fd, ptr, remaining);
    if ((got_eof = (nc <= 0))) {
        if (buf_end > line_start && *(buf_end-1) != '\n') {
            if (got_cr) {
                /* a CR by itself is always converted to a LF */
                got_cr = 0;
                *(buf_end-1) = '\n';
                ptr--; /* repeat */
            } else {
                *buf_end++ = '\n';
                consumed++;
                remaining--;
                got_eof = 0; /* retry */
            }
        } else {
            break;
        }
    } else {
        buf_end = ptr + nc;
    }
}
@

<<Scan buffer>>=
while (got_eof == 0) {
    <<Fill [[buffer]] if it is empty; [[break]] at end of file>>
    c = *ptr++;
    if (c == '\n') {
        /* lf or cr-lf */
#if CONVERT_CRLF_TO_LF
        ptr -= got_cr;
        *(ptr - 1) = '\n';
#endif
        line_count++;
        {
            <<Process Line>>
        }
#if CONVERT_CRLF_TO_LF
        ptr += got_cr;
#endif
        line_start = ptr;
        got_cr = 0;
    } else if (got_cr) {
        /* cr, convert to lf and repeat */
        got_cr = 0;
        ptr -= 2;
        *ptr = '\n';
    } else {
        got_cr = c == '\r';
    }
}
@

<<Scan file>>=
line_start = ptr = buffer;
nc = read(fd, ptr, BUF_SIZE);
if (nc > 0) {
    buf_end = buffer + nc;
    <<Scan buffer>>
}
@

<<Initialize pointers and counters>>=
line_start = ptr = buffer;
line_count = 0;
@

<<If a file is given, try to open [[*(++argv)]]; [[continue]] if unsuccessful>>=
if (file_count > 0) {
    file_name = *(++argv);
    if (strcmp(file_name, "-") == 0) {
        fd = 0; /* stdin */
    } else if ((fd = open(file_name, READ_ONLY)) < 0) {
        fprintf(stderr,
            "%s: cannot open file %s\n",
            prog_name, file_name);
        status |= CANNOT_OPEN_FILE;
        file_count--;
        continue;
    }
} else {
    fd = 0; /* stdin */
    file_name = "-";
}
@

<<Process all the files>>=
argc--;
do {
    <<If a file is given, try to open [[*(++argv)]]; [[continue]] if unsuccessful>>
    <<Initialize pointers and counters>>
    <<Scan file>>
    <<Close file>>
    <<Update grand totals>>
} while (--argc > 0);
@

<<Set up option selection>>=
file_count = argc - 1;
@

<<Variables local to [[main]]>>=
int file_count;         /* how many files there are */
char *file_name;        /* Used to differentiate between *argv and '-' */
int fd;                 /* file descriptor */
char buffer[BUF_SIZE];  /* we read the input into this array */
char *ptr;              /* first unprocessed character in buffer */
char *line_start;       /* where in the buffer the current line starts */
char *buf_end;          /* the first unused position in buffer */
int c;                  /* current char */
ssize_t nc;             /* # of chars just read */
long line_count;        /* # of words, lines, and chars so far */
int got_eof = 0;        /* read got EOF */
int got_cr = 0;         /* previous char was '\r' */
@

<<Local variables initialization>>=
prog_name = argv[0];
@

<<Exit status>>=
exit(status);
return 0;
@

nofake nwsplit.nw | sh -x

<<*>>=
#!/bin/sh
set -eu
<<build nwsplit.c>>
<<build nwsplit>>
@

[[targets]] are used by automatic Makefile generation, see [[Makefile.nw]] for
details.

<<targets>>=
set -- "$@" nwsplit.c
set -- "$@" nwsplit
@

<<nwsplit.c deps>>=
nwsplit.nw
@

<<nwsplit deps>>=
nwsplit.c
@

<<build nwsplit.c>>=
CHMOD='chmod 0444' nofake.sh --error -L -Rnwsplit.c -onwsplit.c <<nwsplit.c deps>>
@

<<build nwsplit - DEBUG>>=
gcc -O0 -g -Wall -ansi -pedantic -o nwsplit nwsplit.c
@

<<build nwsplit - STANDARD>>=
gcc -O2 -Wall -ansi -pedantic -o nwsplit nwsplit.c
@

<<set build PEDANTIC>>=
set -- "$@" -ansi -pedantic
set -- "$@" -Wall -Wextra -Wdeclaration-after-statement
set -- "$@" -Wstrict-prototypes -Wmissing-prototypes
set -- "$@" -Wredundant-decls
set -- "$@" -Wshadow
set -- "$@" -Wpointer-arith
set -- "$@" -Wno-unused-parameter
set -- "$@" -Werror -fmax-errors=3
@

<<build nwsplit - PEDANTIC>>=
set --
<<set build PEDANTIC>>
gcc -O2 "$@" -o nwsplit nwsplit.c
@

<<build nwsplit>>=
#!/bin/sh
set -eu
#@<<build nwsplit - DEBUG>>
#@<<build nwsplit - STANDARD>>
<<build nwsplit - PEDANTIC>>
@
