
Copyright (c) 2024 by C. Tarbide. You may do as you please with
this code as long as you do not remove this copyright notice or
hold me liable for its use.

'end' is exclusive, i.e., len = end - beg

<<structs>>=
struct tkinfo_file_name {
    char *file_name;
};
struct tkinfo_line_number {
    struct tkinfo_file_name *file_name;
    int line_number;
};
struct token {
    struct tkinfo_line_number *line_number;
    char *image;
    int category;
    union tkvalue {
        char punct;     /* cat 5 */
        char hi_lo[2];  /* cat 6 (0x00..0xFF -> 0y@@..0yOO) */
    } value;
};
struct tkscan {
    struct queue *tokens;
    int needatleast;
};
@

<<definitions>>=
#define TKSCAN_PTR(ctx) ((ctx)->beg + (ctx)->pos)
#define TKSCAN_LEN(ctx) ((ctx)->end - TKSCAN_PTR(ctx))
@

<<protos>>=
void
tkscan(struct tkscan *ctx, struct queue *tokens);
@

<<impl>>=
void
tkscan(struct tkscan *ctx, struct queue *tokens)
{
    ctx->tokens = tokens;
    ctx->needatleast = 0;
}
@

<<protos>>=
struct tkinfo_file_name *
new_tkinfo_file_name(struct strscan *ctx);
@

<<impl>>=
struct tkinfo_file_name *
new_tkinfo_file_name(struct strscan *ctx)
{
    struct tkinfo_file_name *res;
    res = calloc(1, sizeof(*res));
    res->file_name = strscan_strdup(ctx);
    return res;
}
@

<<protos>>=
struct tkinfo_line_number *
new_tkinfo_line_number(
    struct tkinfo_file_name *file_name,
    int line_number);
@

<<impl>>=
struct tkinfo_line_number *
new_tkinfo_line_number(
    struct tkinfo_file_name *file_name,
    int line_number)
{
    struct tkinfo_line_number *res;
    res = calloc(1, sizeof(*res));
    res->file_name = file_name;
    res->line_number = line_number;
    return res;
}
@

<<alloc and set token line_number and category>>=
res = calloc(1, sizeof(*res));
res->line_number = line_number;
res->category = category;
@

<<protos>>=
struct token *
new_token_image(
    struct tkinfo_line_number *line_number,
    int category, struct strscan *ctx);
@

<<impl>>=
struct token *
new_token_image(
    struct tkinfo_line_number *line_number,
    int category, struct strscan *ctx)
{
    struct token *res;
    <<alloc and set token line_number and category>>
    res->image = strscan_strdup(ctx);
    return res;
}
@

<<protos>>=
struct token *
new_token_punct(
    struct tkinfo_line_number *line_number,
    int category, int punct);
@

<<impl>>=
struct token *
new_token_punct(
    struct tkinfo_line_number *line_number,
    int category, int punct)
{
    struct token *res;
    <<alloc and set token line_number and category>>
    res->value.punct = punct;
    return res;
}
@

<<protos>>=
struct token *
new_token_hi_lo(
    struct tkinfo_line_number *line_number,
    int category, int hi, int lo);
@

<<impl>>=
struct token *
new_token_hi_lo(
    struct tkinfo_line_number *line_number,
    int category, int hi, int lo)
{
    struct token *res;
    <<alloc and set token line_number and category>>
    res->value.hi_lo[0] = hi;
    res->value.hi_lo[1] = lo;
    return res;
}
@

<<protos SKIP>>=
void rtrim(struct tkscan *ctx);
@

<<impl SKIP>>=
void rtrim(struct tkscan *ctx)
{
    char *b = ctx->beg + ctx->pos;
    char *e = ctx->end - 1;
    if (ctx->fail) return;
    while (e >= b && (*e == ' ' || *e == '\t')) {
        e--;
    }
    ctx->end = e + 1;
}
@

<<definitions>>=
#define PEEK_TOKEN(Q, IDX) ((struct token*)peek_front(Q, IDX))
@

<<protos>>=
int
tkscan_startswith2(struct tkscan *ctx, int x, int y);
@

<<impl>>=
int
tkscan_startswith2(struct tkscan *ctx, int x, int y)
{
    struct queue *q;
    q = ctx->tokens;
    if (ctx->needatleast) return 0;
    if (q->tally < 2) {
        ctx->needatleast = 2;
        return 0;
    }
    if (PEEK_TOKEN(q, 0)->category == x && PEEK_TOKEN(q, 1)->category == y) {
        dequeue_discard(q, 2);
        return 1;
    }
    return 0;
}
@

<<protos SKIP>>=
int
endswith3(struct tkscan *ctx, int x, int y, int z);
@

<<impl SKIP>>=
int
endswith3(struct tkscan *ctx, int x, int y, int z)
{
    char *e = ctx->end;
    size_t l = e - (ctx->beg + ctx->pos);
    if (ctx->fail) return 0;
    if (l < 3) {
        return 0;
    }
    if (e[-3] == x && e[-2] == y && e[-1] == z) {
        ctx->end = e - 3;
        return 1;
    }
    return 0;
}
@

<<protos SKIP>>=
int
exact1(struct tkscan *ctx, int x);
@

<<impl SKIP>>=
int
exact1(struct tkscan *ctx, int x)
{
    char *b = ctx->beg + ctx->pos;
    size_t l = ctx->end - b;
    if (ctx->fail) return 0;
    if (l != 1) {
        return 0;
    }
    if (b[0] == x) {
        ctx->pos++;
        return 1;
    }
    return 0;
}
@

<<protos SKIP>>=
int
hasatleast(struct tkscan *ctx, size_t len);
@

<<impl SKIP>>=
int
hasatleast(struct tkscan *ctx, size_t len)
{
    if (ctx->fail) return 0;
    if ((ctx->end - (ctx->beg + ctx->pos)) >= (ssize_t)len) {
        return 1;
    }
    return 0;
}
@
